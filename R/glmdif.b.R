









# Data Wrangling ----

glmDIFClass <- if (requireNamespace('jmvcore'))
  R6::R6Class(
    "glmDIFClass",
    inherit = glmDIFBase,
    private = list(
      .run = function() {
        if (is.null(self$options$group) |
            is.null(self$data) | is.null(self$options$item)) {
          stop("Please supply a least 1 item variable and a grouping variable.",
                   call. = FALSE)
        }
        # The full DF
        data <- self$data
        
        # Data frame containing all items selected for analysis
        Data <-
          data.frame(sapply(data[, colnames(data) %in% self$options$item], jmvcore::toNumeric))
        colnames(Data) <- self$options$item
        for (i in 1:length(self$options$item)){
          if (!all(unique(Data[,i]) %in% c(0,1, NA))){
            stop(paste("One or more rows contains an invalid value in column: ", colnames(Data)[i]), ". (Item responses must be one of c(0,1,NA))",
                   call. = FALSE)
          }
          # if (length(unique(Data[,i] != 2))){
          #   stop(paste("One or more columns contains only a single value: ", colnames(Data)[i]), ". (Both of c(0,1) must be present for each group for each item)",
          #          call. = FALSE)
          # }
        }
        
        # Vector containing grouping data
        group <- data[, self$options$group]
        
        # Vector containing matching data
        match <-
          data.frame(jmvcore::toNumeric(data[, self$options$matchVar]))
        if (length(match) == 0) {
          match <- "score"
        } else {
          colnames(match) <- self$options$matchVar
          match <- unlist(match)
        }
        
        if (length(self$options$focal) == 0) {
          focalName <- levels(group)[1]
        } else {
          focalName <- self$options$focal
        }
        if (nchar(focalName) > 1) {
          focalName <- unlist(strsplit(focalName, split = "*"))
        }
        
        anchor <-
          data.frame(sapply(data[, colnames(data) %in% self$options$anchor], jmvcore::toNumeric))
        if (length(anchor) == 0) {
          anchor <- NULL
        } else {
          colnames(anchor) <- self$options$anchor
          anchor <- unlist(anchor)
        }
        
        groupType <- self$options$groupType
        
        type <- self$options$type
        
        criterion <- self$options$criterion
        
        alpha <- self$options$alpha
        
        purify <- self$options$purify
        
        nIter <- self$options$nIter
        
        pAdjustMethod <- self$options$pAdjustMethod
        if (pAdjustMethod == "None") {
          pAdjustMethod <- NULL
        }
        # Bootstrap GC ----
        # Print the output of a bootstrap
        
        print.bootSE <- function(x,
                                 digits = getOption("digits"),
                                 index = 1L:ncol(boot.out$t),
                                 ...)
        {
          boot.out <- x
          sim <- boot.out$sim
          cl <- boot.out$call
          t <- matrix(boot.out$t[, index], nrow = nrow(boot.out$t))
          allNA <- apply(t, 2L, function(t)
            all(is.na(t)))
          ind1 <- index[allNA]
          index <- index[!allNA]
          t <- matrix(t[,!allNA], nrow = nrow(t))
          rn <- paste("t", index, "*", sep = "")
          if (length(index) == 0L)
            op <- NULL
          else if (is.null(t0 <- boot.out$t0)) {
            if (is.null(boot.out$call$weights))
              op <- cbind(apply(t, 2L, mean, na.rm = TRUE),
                          sqrt(apply(t, 2L, function(t.st)
                            var(t.st[!is.na(t.st)]))))
            else {
              op <- NULL
              for (i in index)
                op <-
                  rbind(op, imp.moments(boot.out, index = i)$rat)
              op[, 2L] <- sqrt(op[, 2])
            }
            dimnames(op) <- list(rn, c("mean", "std. error"))
            return(op)
          }
          else {
            t0 <- boot.out$t0[index]
            if (is.null(boot.out$call$weights)) {
              op <- cbind(t0, apply(t, 2L, mean, na.rm = TRUE) - t0,
                          sqrt(apply(t, 2L, function(t.st)
                            var(t.st[!is.na(t.st)]))))
              dimnames(op) <-
                list(rn, c("original", " bias  ", " std. error"))
              return(op)
            }
            else {
              op <- NULL
              for (i in index)
                op <-
                  rbind(op, imp.moments(boot.out, index = i)$rat)
              op <- cbind(t0, op[, 1L] - t0, sqrt(op[, 2L]),
                          apply(t, 2L, mean, na.rm = TRUE))
              dimnames(op) <- list(rn, c("original", " bias  ",
                                         " std. error", " mean(t*)"))
              return(op)
            }
          }
          
        }
        
        NagR2 <- function(DATA, ind) {
          ITEM <- (DATA[, 1])
          SCORE <- (DATA[, 2])
          GROUP <- (DATA[, 3])
          n <- nrow(DATA)
          
          m0 <- switch(
            self$options$type,
            both = glm(ITEM[ind] ~ SCORE * GROUP,
                       family = "binomial"),
            udif = glm(ITEM[ind] ~ SCORE +
                         GROUP, family = "binomial"),
            nudif = glm(ITEM[ind] ~ SCORE *
                          GROUP, family = "binomial")
          )
          
          m1 <-
            switch(
              self$options$type,
              both = glm(ITEM[ind] ~ SCORE, family = "binomial"),
              udif = glm(ITEM[ind] ~ SCORE, family = "binomial"),
              nudif = glm(ITEM[ind] ~
                            SCORE + GROUP, family = "binomial")
            )
          
          R2cox0 <-  1 - exp((m0$deviance - m0$null.deviance) / n)
          R2nag0 <-  R2cox0 / (1 - exp((-m0$null.deviance) / n))
          
          R2cox1 <-  1 - exp((m1$deviance - m1$null.deviance) / n)
          R2nag1 <-  R2cox1 / (1 - exp((-m1$null.deviance) / n))
          
          deltaNagR2 <- R2nag0 - R2nag1
          return(deltaNagR2)
        }
        
        empDist <- function(DATA, hypTrueEff) {
          alpha <- self$options$alpha
          empRes <- matrix(0, nrow = 1, ncol = 3)
          # Get bootstrapped distribution
          myBoot <- boot(DATA, NagR2, R = 1000)
          # se of emp. dist.
          se <- print.bootSE(myBoot)[[3]]
          # Density values for use below
          D <- density(myBoot$t, n = 1024)
          # calculate 2.5% and 97.5% quantiles. This will be needed to find the "reject region."
          # length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
          quant <- quantile(D$x, c(alpha / 2, 1 - (alpha / 2)))
          # points in the probability distribution matching the Lower and Upper quantiles
          p.lo <- quant[[1]]
          p.hi <- quant[[2]]
          # Here there be monsters

          ## shifts distribution by the difference between the observed effect size and the empirical effect size
          D.shifted <- myBoot$t + (hypTrueEff-myBoot$t0)
          ## Calculate shifted distribution. 
          D.shifted <- density(D.shifted, n = 1024)$x
          ##returns the fraction of elements of D.shift that fall into the reject regions of the unshifted distribution.
          rejects = sum((D.shifted < p.lo | D.shifted > p.hi) == T)
          ##calculates the proportion of rejects among all bootstrapped samples.
          ##This is the power of the test.
          powerR <- rejects / length(rejects)
          empRes[1, 3] <- powerR
          # Type-S error rate
          typeSError <- p.lo / powerR
          empRes[1, 1] <- typeSError
          # typeM error rate
          estimate <-
            hypTrueEff + se * sample(D$x, replace = T, size = self$options$sims)
          significant <-
            estimate < se * qUpper  | estimate > se * qUpper
          typeMError <-
            mean(abs(estimate)[significant]) / hypTrueEff
          empRes[1, 2] <- typeMError
          return(empRes)
        }
        
        # DIF ----
        # difLogReg is a starter function to determine whether GLM or LM should be used, as well as QA on the arguments input
        
        difLogReg <-
          function (Data,
                    group,
                    focalName,
                    anchor = NULL,
                    groupType = "group",
                    match = "score",
                    type = "both",
                    criterion = "LRT",
                    alpha = 0.05,
                    purify = FALSE,
                    nrIter = 10,
                    pAdjustMethod = NULL)
          {
            if (groupType != "group" & groupType != "cont")
              stop("'groupType' must be either 'group' or 'cont'",
                   call. = FALSE)
            if (purify & match[1] != "score")
              stop("purification not allowed when matching variable is not 'score'",
                   call. = FALSE)
            if (groupType == "group" & length(focalName) > 1) {
              # If there is more than one focal group selected, use Generalized Logistic Regression
              stop(paste0(
                "Only one reference group may be provided, and it must be a value from the provided grouping variable. You have input: ", self$options$focal
                
              ))
              # res <-
              #   difGenLogistic(
              #     Data = Data,
              #     group = group,
              #     focalName = focalName,
              #     anchor = anchor,
              #     match = match,
              #     type = type,
              #     criterion = criterion,
              #     alpha = alpha,
              #     purify = purify,
              #     nrIter = nrIter,
              #     pAdjustMethod = pAdjustMethod
              #   )
            } else {
              # If there is one or no focal group selected, use regular Logistic Regression
              res <-
                difLogistic(
                  Data = Data,
                  group = group,
                  focalName = focalName,
                  anchor = anchor,
                  memberType = groupType,
                  match = match,
                  type = type,
                  criterion = criterion,
                  alpha = alpha,
                  purify = purify,
                  nrIter = nrIter,
                  pAdjustMethod = pAdjustMethod
                )
              return(res)
            }
          }
        difLogistic <-
          function (Data,
                    group,
                    focalName,
                    anchor = NULL,
                    memberType = "group",
                    match = "score",
                    type = "both",
                    criterion = "LRT",
                    alpha = 0.05,
                    all.cov = TRUE,
                    purify = FALSE,
                    nrIter = 10,
                    pAdjustMethod = NULL)
          {
            # if (memberType != "group" & memberType != "cont")
            #   stop("'memberType' must be either 'group' or 'cont'",
            #        call. = FALSE)
            if (purify & match[1] != "score")
              stop("purification not allowed when matching variable is not 'score'",
                   call. = FALSE)
            internalLog <- function() {
              # if (length(group) == 1) {
              #   if (is.numeric(group)) {
              #     gr <- Data[, group]
              #     DATA <- Data[, (1:NCOL(Data)) != group]
              #     colnames(DATA) <- colnames(Data)[(1:NCOL(Data)) !=
              #                                        group]
              #   }
              #   else {
              #     gr <- Data[, colnames(Data) == group]
              #     DATA <- Data[, colnames(Data) != group]
              #     colnames(DATA) <- colnames(Data)[colnames(Data) !=
              #                                        group]
              #   }
              # }
              # else {
                gr <- group
                DATA <- Data
              # }
              if (memberType == "group") {
                Group <- rep(0, NROW(DATA))
                Group[gr == focalName] <- 1
              }
              else
                Group <- gr
              Q <-
                switch(
                  type,
                  both = qchisq(1 - alpha, 2),
                  udif = qchisq(1 -
                                  alpha, 1),
                  nudif = qchisq(1 - alpha, 1)
                )
              if (!is.null(anchor)) {
                dif.anchor <- anchor
                if (is.numeric(anchor))
                  ANCHOR <- anchor
                else {
                  ANCHOR <- NULL
                  for (i in 1:length(anchor))
                    ANCHOR[i] <- (1:NCOL(DATA))[colnames(DATA) ==
                                                  anchor[i]]
                }
              }
              else {
                ANCHOR <- 1:NCOL(DATA)
                dif.anchor <- NULL
              }
              DDF <- ifelse(type == "both", 2, 1)
              
              # Purification == FALSE ----
              
              if (!purify |
                  match[1] != "score" | !is.null(anchor)) {
                PROV <- Logistik(
                  DATA,
                  Group,
                  memberType = memberType,
                  match = match,
                  type = type,
                  criterion = criterion,
                  anchor = ANCHOR,
                  all.cov = all.cov
                )
                STATS <- PROV$stat
                PVAL <- 1 - pchisq(STATS, DDF)
                deltaR2 <- PROV$deltaR2
                if (max(STATS) <= Q) {
                  DIFitems <- "No DIF item detected"
                  logitPar <- PROV$parM1
                  logitSe <- PROV$seM1
                }
                else {
                  DIFitems <- (1:NCOL(DATA))[STATS > Q]
                  logitPar <- PROV$parM1
                  logitSe <- PROV$seM1
                  for (idif in 1:length(DIFitems)) {
                    logitPar[DIFitems[idif],] <- PROV$parM0[DIFitems[idif],]
                    logitSe[DIFitems[idif],] <-
                      PROV$seM0[DIFitems[idif],]
                  }
                }
                RES <-
                  list(
                    Logistik = STATS,
                    p.value = PVAL,
                    logitPar = logitPar,
                    logitSe = logitSe,
                    parM0 = PROV$parM0,
                    seM0 = PROV$seM0,
                    parM1 = PROV$parM1,
                    seM1 = PROV$seM1,
                    cov.M0 = PROV$cov.M0,
                    cov.M1 = PROV$cov.M1,
                    deltaR2 = deltaR2,
                    GC = PROV$GC,
                    alpha = alpha,
                    thr = Q,
                    DIFitems = DIFitems,
                    memberType = memberType,
                    match = PROV$match,
                    type = type,
                    pAdjustMethod = pAdjustMethod,
                    adjusted.p = NULL,
                    purification = purify,
                    names = colnames(DATA),
                    anchor.names = dif.anchor,
                    criterion = criterion,
                    focalName = focalName,
                    ZT = as.character(symnum(
                      deltaR2,
                      c(0, 0.13, 0.26, 1),
                      symbols = c("A", "B", "C"),
                      legend = FALSE
                    )),
                    JG = as.character(symnum(
                      deltaR2,
                      c(0, 0.035, 0.07, 1),
                      symbols = c("A", "B", "C"),
                      legend = FALSE
                    ))
                  )
                if (!is.null(anchor) & match[1] == "score") {
                  RES$Logistik[ANCHOR] <- NA
                  RES$logitPar[ANCHOR,] <- NA
                  RES$parM0[ANCHOR,] <- NA
                  RES$deltaR2[ANCHOR] <- NA
                  for (i in 1:length(RES$DIFitems)) {
                    if (sum(RES$DIFitems[i] == ANCHOR) == 1)
                      RES$DIFitems[i] <- NA
                  }
                  RES$DIFitems <- RES$DIFitems[!is.na(RES$DIFitems)]
                }
              }
              # Purification == TRUE ----
              else {
                nrPur <- 0
                difPur <- NULL
                noLoop <- FALSE
                prov1 <-
                  Logistik(
                    DATA,
                    Group,
                    memberType = memberType,
                    match = match,
                    type = type,
                    criterion = criterion,
                    all.cov = all.cov
                  )
                stats1 <- prov1$stat
                deltaR2 <- prov1$deltaR2
                if (max(stats1) <= Q) {
                  DIFitems <- "No DIF item detected"
                  logitPar <- prov1$parM1
                  logitSe <- prov1$seM1
                  noLoop <- TRUE
                }
                else {
                  dif <- (1:NCOL(DATA))[stats1 > Q]
                  difPur <- rep(0, length(stats1))
                  difPur[dif] <- 1
                  repeat {
                    if (nrPur >= nrIter)
                      break
                    else {
                      nrPur <- nrPur + 1
                      nodif <- NULL
                      if (is.null(dif))
                        nodif <- 1:NCOL(DATA)
                      else {
                        for (i in 1:NCOL(DATA)) {
                          if (sum(i == dif) == 0)
                            nodif <- c(nodif, i)
                        }
                      }
                      prov2 <- Logistik(
                        DATA,
                        Group,
                        anchor = nodif,
                        memberType = memberType,
                        match = match,
                        type = type,
                        criterion = criterion,
                        all.cov = all.cov
                      )
                      stats2 <- prov2$stat
                      deltaR2 <- prov2$deltaR2
                      if (max(stats2) <= Q)
                        dif2 <- NULL
                      else
                        dif2 <- (1:NCOL(DATA))[stats2 > Q]
                      difPur <- rbind(difPur, rep(0, NCOL(DATA)))
                      difPur[nrPur + 1, dif2] <- 1
                      if (length(dif) != length(dif2))
                        dif <- dif2
                      else {
                        dif <- sort(dif)
                        dif2 <- sort(dif2)
                        if (sum(dif == dif2) == length(dif)) {
                          noLoop <- TRUE
                          break
                        }
                        else
                          dif <- dif2
                      }
                    }
                  }
                  prov1 <- prov2
                  stats1 <- stats2
                  PVAL <- 1 - pchisq(stats1, DDF)
                  deltaR2 <- deltaR2
                  DIFitems <- (1:NCOL(DATA))[stats1 > Q]
                  logitPar <- prov1$parM1
                  logitSe <- prov1$seM1
                  for (idif in 1:length(DIFitems)) {
                    logitPar[DIFitems[idif],] <- prov1$parM0[DIFitems[idif],]
                    logitSe[DIFitems[idif],] <-
                      prov1$seM0[DIFitems[idif],]
                  }
                }
                if (is.null(difPur) == FALSE) {
                  ro <- co <- NULL
                  for (ir in 1:NROW(difPur))
                    ro[ir] <- paste("Step",
                                    ir - 1, sep = "")
                  for (ic in 1:NCOL(difPur))
                    co[ic] <- paste("Item",
                                    ic, sep = "")
                  rownames(difPur) <- ro
                  colnames(difPur) <- co
                }
                RES <-
                  list(
                    Logistik = stats1,
                    # p.value = PVAL,
                    logitPar = logitPar,
                    logitSe = logitSe,
                    parM0 = prov1$parM0,
                    seM0 = prov1$seM0,
                    cov.M0 = prov1$cov.M0,
                    cov.M1 = prov1$cov.M1,
                    deltaR2 = deltaR2,
                    alpha = alpha,
                    thr = Q,
                    DIFitems = DIFitems,
                    memberType = memberType,
                    match = prov1$match,
                    type = type,
                    pAdjustMethod = pAdjustMethod,
                    adjusted.p = NULL,
                    purification = purify,
                    nrPur = nrPur,
                    difPur = difPur,
                    convergence = noLoop,
                    names = colnames(DATA),
                    anchor.names = NULL,
                    criterion = criterion,
                    focalName = focalName,
                    ZT = as.character(symnum(
                      deltaR2,
                      c(0, 0.13, 0.26, 1),
                      symbols = c("A", "B", "C"),
                      legend = FALSE
                    )),
                    JG = as.character(symnum(
                      deltaR2,
                      c(0, 0.035, 0.07, 1),
                      symbols = c("A", "B", "C"),
                      legend = FALSE
                    ))
                  )
              }
              # p-Adjust ----
              if (!is.null(pAdjustMethod)) {
                df <- switch(RES$type,
                             both = 2,
                             udif = 1,
                             nudif = 1)
                pval <- 1 - pchisq(RES$Logistik, df)
                RES$adjusted.p <-
                  p.adjust(pval, method = pAdjustMethod)
                if (min(RES$adjusted.p, na.rm = TRUE) > alpha)
                  RES$DIFitems <- "No DIF item detected"
                else
                  RES$DIFitems <- which(RES$adjusted.p < alpha)
              }
              class(RES) <- "Logistic"
              return(RES)
            }
            resToReturn <- internalLog()
            
            return(resToReturn)
          }
        
        Logistik <-
          function (data,
                    member,
                    memberType = "group",
                    match = "score",
                    anchor = 1:NCOL(data),
                    type = "both",
                    criterion = "LRT",
                    all.cov = TRUE)
          {
            R2 <-
              function(m, n)
                1 - (exp(-m$null.deviance / 2 + m$deviance / 2)) ^ (2 / n)
            R2max <- function(m, n)
              1 - (exp(-m$null.deviance / 2)) ^ (2 / n)
            R2DIF <- function(m, n)
              R2(m, n) / R2max(m, n)
            dev <- R2full <- R2simple <- deltaR <- NULL
            mFull <-
              mSimple <- seFull <- seSimple <- matrix(0, NCOL(data),
                                                      4)
            if (self$options$difFlagScale == "zt") {
              hypTrueEff <- c(0.13, 0.26)
            } else {
              hypTrueEff <- c(0.035, 0.07)
            }
            
            GC <-
              matrix(0,
                     nrow = NCOL(data) * length(hypTrueEff),
                     4,
                     dimnames = list(c(rep(
                       hypTrueEff, times = NCOL(data)
                     )), c("item", "typeS", "typeM", "power")))
            if (all.cov)
              cov.matM0 <- cov.matM1 <- vector("list", NCOL(data))
            else
              cov.matM0 <- cov.matM1 <- NULL
            if (memberType == "group")
              GROUP <- as.factor(member)
            else
              GROUP <- member
            for (item in 1:ncol(data)) {
              private$.checkpoint()
              if (match[1] == "score") {
                data2 <- rbind(data[, anchor])
                if (sum(anchor == item) == 0)
                  data2 <- cbind(data2, data[, item])
                SCORES <- rowSums(data2, na.rm = TRUE)
              }
              else
                SCORES <- match
              ITEM <- data[, item]
              m0 <- switch(
                type,
                both = glm(ITEM ~ SCORES * GROUP,
                           family = "binomial"),
                udif = glm(ITEM ~ SCORES +
                             GROUP, family = "binomial"),
                nudif = glm(ITEM ~ SCORES *
                              GROUP, family = "binomial")
              )
              
              m1 <-
                switch(
                  type,
                  both = glm(ITEM ~ SCORES, family = "binomial"),
                  udif = glm(ITEM ~ SCORES, family = "binomial"),
                  nudif = glm(ITEM ~
                                SCORES + GROUP, family = "binomial")
                )
              if (criterion == "LRT")
                dev[item] <- deviance(m1) - deviance(m0)
              else {
                if (criterion != "Wald")
                  stop("'criterion' must be either 'LRT' or Wald'",
                       call. = FALSE)
                else {
                  coeff <- as.numeric(coefficients(m0))
                  covMat <- summary(m0)$cov.scaled
                  if (type == "udif")
                    C <- rbind(c(0, 0, 1))
                  else {
                    if (type == "nudif")
                      C <- rbind(c(0, 0, 0, 1))
                    else
                      C <- rbind(c(0, 0, 1, 0), c(0, 0, 0, 1))
                  }
                  dev[item] <-
                    t(C %*% coeff) %*% solve(C %*% covMat %*%
                                               t(C)) %*% C %*% coeff
                }
              }
              
              if (self$options$designAnalysisSigOnly) {
                sigThresh <-
                  switch(
                    type,
                    both = qchisq(1 - alpha, 2),
                    udif = qchisq(1 -
                                    alpha, 1),
                    nudif = qchisq(1 - alpha, 1)
                  )
              } else{
                sigThresh <- 0
              }
              
              if (dev[item] > sigThresh) {
                if (self$options$designAnalysis) {
                  empDATA <- data.frame(ITEM, GROUP, SCORES)
                  tick <- item - 1
                  for (hypInd in 1:length(hypTrueEff)) {
                    private$.checkpoint()
                    GC[item + tick, 1] <- item
                    GC[item + tick, 2:4] <-
                      empDist(empDATA, hypTrueEff = hypTrueEff[hypInd])
                  

                    buildGC(GC, item + tick, colnames(data)[item])
                    tick <- tick + 1
                  }
                }
              }
              
              R2full[item] <- R2DIF(m0, NROW(data))
              R2simple[item] <- R2DIF(m1, NROW(data))
              deltaR[item] <-
                R2DIF(m0, NROW(data)) - R2DIF(m1, NROW(data))
              mFull[item, 1:length(m0$coefficients)] <-
                m0$coefficients
              mSimple[item, 1:length(m1$coefficients)] <-
                m1$coefficients
              seFull[item, 1:length(m0$coefficients)] <-
                sqrt(diag(vcov(m0)))
              seSimple[item, 1:length(m1$coefficients)] <-
                sqrt(diag(vcov(m1)))
              if (all.cov)
                cov.matM0[[item]] <- vcov(m0)
              if (all.cov)
                cov.matM1[[item]] <- vcov(m1)
            }
            colnames(mFull) <-
              colnames(mSimple) <-
              colnames(seFull) <-
              colnames(seSimple) <- c("(Intercept)",
                                      "SCORE", "GROUP", "SCORE:GROUP")
            res <-
              list(
                stat = dev,
                R2M0 = R2full,
                R2M1 = R2simple,
                deltaR2 = deltaR,
                GC = GC,
                parM0 = mFull,
                parM1 = mSimple,
                seM0 = seFull,
                seM1 = seSimple,
                cov.M0 = cov.matM0,
                cov.M1 = cov.matM1,
                criterion = criterion,
                memberType = memberType,
                match = ifelse(match[1] ==
                                 "score", "score", "matching variable")
              )
            return(res)
          }
        # GenLogistic ----
        # difGenLogistic <-
        #   function (Data,
        #             group,
        #             focalName,
        #             anchor = NULL,
        #             match = "score",
        #             type = "both",
        #             criterion = "LRT",
        #             alpha = 0.05,
        #             purify = FALSE,
        #             nrIter = 10,
        #             pAdjustMethod = NULL)
        #   {
        #     if (purify & match[1] != "score")
        #       stop("purification not allowed when matching variable is not 'score'",
        #            call. = FALSE)
        #     internalGenLog <- function() {
        #       if (length(focalName) == 1)
        #         RES <-
        #           difLogistic(
        #             Data,
        #             group,
        #             focalName = focalName,
        #             memberType = "group",
        #             match = match,
        #             type = type,
        #             alpha = alpha,
        #             pAdjustMethod = pAdjustMethod,
        #             purify = purify,
        #             nrIter = nrIter,
        #             focalName = focalName,
        #             ZT = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.13, 0.26, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             )),
        #             JG = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.035, 0.07, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             ))
        #           )
        #       else {
        #         if (length(group) == 1) {
        #           if (is.numeric(group)) {
        #             gr <- Data[, group]
        #             DATA <- Data[, (1:NCOL(Data)) != group]
        #             colnames(DATA) <-
        #               colnames(Data)[(1:NCOL(Data)) !=
        #                                group]
        #           }
        #           else {
        #             gr <- Data[, colnames(Data) == group]
        #             DATA <- Data[, colnames(Data) != group]
        #             colnames(DATA) <-
        #               colnames(Data)[colnames(Data) !=
        #                                group]
        #           }
        #         }
        #         else {
        #           gr <- group
        #           DATA <- Data
        #         }
        #         Group <- rep(0, NROW(DATA))
        #         DF <- length(focalName)
        #         DDF <- ifelse(type == "both", 2 * DF, DF)
        #         for (i in 1:DF)
        #           Group[gr == focalName[i]] <- i
        #         Q <- switch(
        #           type,
        #           both = qchisq(1 - alpha, 2 * DF),
        #           udif = qchisq(1 - alpha, DF),
        #           nudif = qchisq(1 -
        #                            alpha, DF)
        #         )
        #         if (!is.null(anchor)) {
        #           dif.anchor <- anchor
        #           if (is.numeric(anchor))
        #             ANCHOR <- anchor
        #           else {
        #             ANCHOR <- NULL
        #             for (i in 1:length(anchor))
        #               ANCHOR[i] <- (1:NCOL(DATA))[colnames(DATA) ==
        #                                             anchor[i]]
        #           }
        #         }
        #         else {
        #           ANCHOR <- 1:NCOL(DATA)
        #           dif.anchor <- NULL
        #         }
        #         if (!purify |
        #             match[1] != "score" | !is.null(anchor)) {
        #           PROV <- genLogistik(
        #             DATA,
        #             Group,
        #             match = match,
        #             type = type,
        #             criterion = criterion,
        #             anchor = ANCHOR
        #           )
        #
        #
        #
        #           STATS <- PROV$stat
        #           PVAL <- 1 - pchisq(STATS, DDF)
        #           deltaR2 <- PROV$deltaR2
        #           covMat <- PROV$covMat
        #           if (max(STATS) <= Q) {
        #             DIFitems <- "No DIF item detected"
        #             logitPar <- PROV$parM1
        #           }
        #           else {
        #             DIFitems <- (1:NCOL(DATA))[STATS > Q]
        #             logitPar <- PROV$parM1
        #             for (idif in 1:length(DIFitems))
        #               logitPar[DIFitems[idif],] <-
        #               PROV$parM0[DIFitems[idif],]
        #           }
        #           RES <- list(
        #             genLogistik = STATS,
        #             p.value = PVAL,
        #             logitPar = logitPar,
        #             parM0 = PROV$parM0,
        #             parM1 = PROV$parM1,
        #             covMat = covMat,
        #             deltaR2 = deltaR2,
        #             alpha = alpha,
        #             thr = Q,
        #             DIFitems = DIFitems,
        #             match = PROV$match,
        #             type = type,
        #             pAdjustMethod = pAdjustMethod,
        #             adjusted.p = NULL,
        #             purification = purify,
        #             names = colnames(DATA),
        #             anchor.names = dif.anchor,
        #             focalName = focalName,
        #             criterion = criterion,
        #             ZT = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.13, 0.26, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             )),
        #             JG = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.035, 0.07, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             ))
        #           )
        #           if (!is.null(anchor) & match[1] == "score") {
        #             RES$genLogistik[ANCHOR] <- NA
        #             RES$logitPar[ANCHOR,] <- NA
        #             RES$parM0[ANCHOR,] <- NA
        #             RES$covMat[, , ANCHOR] <- NA
        #             RES$deltaR2[ANCHOR] <- NA
        #             for (i in 1:length(RES$DIFitems)) {
        #               if (sum(RES$DIFitems[i] == ANCHOR) == 1)
        #                 RES$DIFitems[i] <- NA
        #             }
        #             RES$DIFitems <-
        #               RES$DIFitems[!is.na(RES$DIFitems)]
        #           }
        #         }
        #         else {
        #           nrPur <- 0
        #           difPur <- NULL
        #           noLoop <- FALSE
        #           prov1 <- genLogistik(
        #             DATA,
        #             Group,
        #             match = match,
        #             type = type,
        #             criterion = criterion
        #           )
        #           stats1 <- prov1$stat
        #           deltaR2 <- prov1$deltaR2
        #           covMat <- prov1$covMat
        #           if (max(stats1) <= Q) {
        #             DIFitems <- "No DIF item detected"
        #             logitPar <- prov1$parM1
        #             noLoop <- TRUE
        #           }
        #           else {
        #             dif <- (1:NCOL(DATA))[stats1 > Q]
        #             difPur <- rep(0, length(stats1))
        #             difPur[dif] <- 1
        #             repeat {
        #               if (nrPur >= nrIter)
        #                 break
        #               else {
        #                 nrPur <- nrPur + 1
        #                 nodif <- NULL
        #                 if (is.null(dif) == TRUE)
        #                   nodif <- 1:NCOL(DATA)
        #                 else {
        #                   for (i in 1:NCOL(DATA)) {
        #                     if (sum(i == dif) == 0)
        #                       nodif <- c(nodif, i)
        #                   }
        #                 }
        #                 prov2 <-
        #                   genLogistik(
        #                     DATA,
        #                     Group,
        #                     anchor = nodif,
        #                     match = match,
        #                     type = type,
        #                     criterion = criterion
        #                   )
        #                 stats2 <- prov2$stat
        #                 deltaR2 <- prov2$deltaR2
        #                 covMat <- prov2$covMat
        #                 if (max(stats2) <= Q)
        #                   dif2 <- NULL
        #                 else
        #                   dif2 <- (1:NCOL(DATA))[stats2 > Q]
        #                 difPur <- rbind(difPur, rep(0, NCOL(DATA)))
        #                 difPur[nrPur + 1, dif2] <- 1
        #                 if (length(dif) != length(dif2))
        #                   dif <- dif2
        #                 else {
        #                   dif <- sort(dif)
        #                   dif2 <- sort(dif2)
        #                   if (sum(dif == dif2) == length(dif)) {
        #                     noLoop <- TRUE
        #                     break
        #                   }
        #                   else
        #                     dif <- dif2
        #                 }
        #               }
        #             }
        #             prov1 <- prov2
        #             stats1 <- stats2
        #             PVAL <- 1 - pchisq(stats1, DDF)
        #             deltaR2 <- deltaR2
        #             covMat <- covMat
        #             DIFitems <- (1:NCOL(DATA))[stats1 > Q]
        #             logitPar <- prov1$parM1
        #             for (idif in 1:length(DIFitems))
        #               logitPar[DIFitems[idif],] <-
        #               prov1$parM0[DIFitems[idif],]
        #           }
        #           if (!is.null(difPur)) {
        #             ro <- co <- NULL
        #             for (ir in 1:NROW(difPur))
        #               ro[ir] <- paste("Step",
        #                               ir - 1, sep = "")
        #             for (ic in 1:NCOL(difPur))
        #               co[ic] <- paste("Item",
        #                               ic, sep = "")
        #             rownames(difPur) <- ro
        #             colnames(difPur) <- co
        #           }
        #           RES <- list(
        #             genLogistik = stats1,
        #             p.value = PVAL,
        #             logitPar = logitPar,
        #             parM0 = prov1$parM0,
        #             covMat = covMat,
        #             deltaR2 = deltaR2,
        #             alpha = alpha,
        #             thr = Q,
        #             DIFitems = DIFitems,
        #             match = prov1$match,
        #             type = type,
        #             pAdjustMethod = pAdjustMethod,
        #             adjusted.p = NULL,
        #             purification = purify,
        #             nrPur = nrPur,
        #             difPur = difPur,
        #             convergence = noLoop,
        #             names = colnames(DATA),
        #             anchor.names = NULL,
        #             focalName = focalName,
        #             criterion = criterion,
        #             focalName = focalName,
        #             ZT = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.13, 0.26, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             )),
        #             JG = as.character(symnum(
        #               deltaR2,
        #               c(0, 0.035, 0.07, 1),
        #               symbols = c("A", "B", "C"),
        #               legend = FALSE
        #             ))
        #           )
        #         }
        #         if (!is.null(pAdjustMethod)) {
        #           nGroups <- length(RES$focalName)
        #           df <-
        #             switch(
        #               RES$type,
        #               both = 2 * nGroups,
        #               udif = nGroups,
        #               nudif = nGroups
        #             )
        #           pval <- 1 - pchisq(RES$genLogistik, df)
        #           RES$adjusted.p <-
        #             p.adjust(pval, method = pAdjustMethod)
        #           if (min(RES$adjusted.p, na.rm = TRUE) > alpha)
        #             RES$DIFitems <- "No DIF item detected"
        #           else
        #             RES$DIFitems <- which(RES$adjusted.p < alpha)
        #         }
        #         class(RES) <- "genLogistic"
        #       }
        #       return(RES)
        #     }
        #     resToReturn <- internalGenLog()
        #
        #     return(resToReturn)
        #   }
        #
        # genLogistik <-
        #   function (data,
        #             member,
        #             match = "score",
        #             anchor = 1:NCOL(data),
        #             type = "both",
        #             criterion = "LRT")
        #   {
        #     R2 <-
        #       function(m, n)
        #         1 - (exp(-m$null.deviance / 2) / exp(-m$deviance / 2)) ^ (2 / n)
        #     R2max <- function(m, n)
        #       1 - (exp(-m$null.deviance / 2)) ^ (2 / n)
        #     R2DIF <- function(m, n)
        #       R2(m, n) / R2max(m, n)
        #     dev <-
        #       R2full <- R2simple <- deltaR <- rep(NA, NCOL(data))
        #     nGroup <- length(unique(member)) - 1
        #     mFull <-
        #       mSimple <- matrix(0, NCOL(data), 2 + 2 * nGroup)
        #     if (type == "udif") {
        #       sigmaMat <- rep(NA, (2 + nGroup) * (2 + nGroup) * NCOL(data))
        #       dim(sigmaMat) <- c(2 + nGroup, 2 + nGroup, NCOL(data))
        #     }
        #     else {
        #       sigmaMat <- rep(NA, (2 + 2 * nGroup) * (2 + 2 * nGroup) *
        #                         NCOL(data))
        #       dim(sigmaMat) <-
        #         c(2 + 2 * nGroup, 2 + 2 * nGroup, NCOL(data))
        #     }
        #     for (item in 1:NCOL(data)) {
        #       if (match[1] == "score") {
        #         data2 <- data[, anchor]
        #         if (sum(anchor == item) == 0)
        #           data2 <- cbind(data2, data[, item])
        #         SCORES <- rowSums(data2, na.rm = TRUE)
        #       }
        #       else
        #         SCORES <- match
        #       GROUP <- as.factor(member)
        #       ITEM <- data[, item]
        #       m0 <- switch(
        #         type,
        #         both = glm(ITEM ~ SCORES * GROUP,
        #                    family = "binomial"),
        #         udif = glm(ITEM ~ SCORES +
        #                      GROUP, family = "binomial"),
        #         nudif = glm(ITEM ~ SCORES *
        #                       GROUP, family = "binomial")
        #       )
        #       m1 <-
        #         switch(
        #           type,
        #           both = glm(ITEM ~ SCORES, family = "binomial"),
        #           udif = glm(ITEM ~ SCORES, family = "binomial"),
        #           nudif = glm(ITEM ~
        #                         SCORES + GROUP, family = "binomial")
        #         )
        #       if (criterion == "LRT") {
        #         dev[item] <- deviance(m1) - deviance(m0)
        #         covMat <- summary(m0)$cov.scaled
        #         sigmaMat[, , item] <- covMat
        #       }
        #       else {
        #         if (criterion != "Wald")
        #           stop("'criterion' must be either 'LRT' or Wald'",
        #                call. = FALSE)
        #         else {
        #           coeff <- as.numeric(coefficients(m0))
        #           covMat <- summary(m0)$cov.scaled
        #           sigmaMat[, , item] <- covMat
        #           if (type == "udif") {
        #             C <- matrix(0, nGroup, length(coeff))
        #             for (tt in 1:nGroup)
        #               C[tt, 2 + tt] <- 1
        #           }
        #           else {
        #             if (type == "nudif") {
        #               C <- matrix(0, nGroup, length(coeff))
        #               for (tt in 1:nGroup)
        #                 C[tt, 2 + nGroup + tt] <- 1
        #             }
        #             else {
        #               C <- matrix(0, nGroup * 2, length(coeff))
        #               for (tt in 1:(2 * nGroup))
        #                 C[tt, 2 + tt] <- 1
        #             }
        #           }
        #           dev[item] <-
        #             t(C %*% coeff) %*% solve(C %*% covMat %*%
        #                                        t(C)) %*% C %*% coeff
        #         }
        #       }
        #       R2full[item] <- R2DIF(m0, NROW(data))
        #       R2simple[item] <- R2DIF(m1, NROW(data))
        #       deltaR[item] <-
        #         R2DIF(m0, NROW(data)) - R2DIF(m1, NROW(data))
        #       mFull[item, 1:length(m0$coefficients)] <-
        #         m0$coefficients
        #       mSimple[item, 1:length(m1$coefficients)] <-
        #         m1$coefficients
        #     }
        #     names <- c("(Intercept)", "SCORE")
        #     GE <- sort(unique(member))
        #     for (i in 2:length(GE))
        #       names <- c(names, paste("GROUP",
        #                               GE[i], sep = ""))
        #     for (i in 2:length(GE))
        #       names <- c(names, paste("SCORE:GROUP",
        #                               GE[i], sep = ""))
        #     colnames(mFull) <- colnames(mSimple) <- names
        #     res <-
        #       list(
        #         stat = dev,
        #         R2M0 = R2full,
        #         R2M1 = R2simple,
        #         deltaR2 = deltaR,
        #         parM0 = mFull,
        #         parM1 = mSimple,
        #         covMat = sigmaMat,
        #         criterion = criterion,
        #         match = ifelse(match[1] == "score", "score", "matching variable")
        #       )
        #     return(res)
        #   }
        
        # retroDesign <-
        #   function(D,
        #            # True effect size
        #            s,
        #            # SE of the estimate
        #            alpha = alpha,
        #            # alpha for the hypothesis test
        #            df = Inf,
        #            # DF, defaults to INF for approximating a normal distribution in the T-distribution
        #            n.sims = self$options$sims)
        #     # Number of simulations to run
        #   {
        #     # Dataframe to hold results
        #     res <-
        #       data.frame(
        #         typeS = rep(0, length(s)),
        #         typeM = rep(0, length(s)),
        #         power = rep(0, length(s))
        #       )
        #     for (i in 1:length(s)) {
        #       z <- qt(1 - alpha / 2, df)
        #       p.hi <- 1 - pt(z - De / s, df)
        #       p.lo <- pt(-z - De / s, df)
        #       power <- p.hi + p.lo
        #       res[i, 3] <- power
        #       # typeS
        #       res[i, 1] <- p.lo / power
        #       # typeM
        #       estimate <- D + s * rt(n.sims, df)
        #       significant <- abs(estimate) > s * z
        #       res[i, 2] <- mean(abs(estimate)[significant]) / D
        #     }
        #     return(res)
        #   }
        #

        # Results functions ----
        
        highlight <- function(table, column, i) {
          table$addFormat(rowNo = i,
                          col = column,
                          format = jmvcore::Cell.NEGATIVE)
        }
        
        
        buildGC <- function(GC, item, name) {
          table <- self$results$gcTable
          if (GC[item, 1] != 0) {
            table$addRow(
              rowKey = item,
              values = list(
                item = name,
                hypTrueEff = ifelse(
                  rownames(GC)[item] == 0.13 | rownames(GC)[item] == 0.035,
                  paste0(rownames(GC)[item], " (B)"),
                  paste0(rownames(GC)[item], " (C)")
                ),
                typeS = GC[item, 2],
                typeM = GC[item, 3],
                power = GC[item, 4]
              )
            )
            # }
          }
          # if (self$options$difFlagScale) {
          #   if (model$ZT[i] %in% c("B", "C") & model$adjusted.p[i] <= alpha) {
          #     highlight(table, "item")
          #   }
          # }
          # if (self$options$difFlagScale) {
          #   if (model$JG[i] %in% c("B", "C") & model$adjusted.p[i] <= alpha) {
          #     highlight(table, "item")
          #   }
          # }
        }
        # }
        # }
        
        # Model ----
        
        model <-
          difLogReg(
            Data = Data,
            group = group,
            focalName = focalName,
            anchor = anchor,
            groupType = groupType,
            match = match,
            type = type,
            criterion = criterion,
            alpha = alpha,
            purify = purify,
            pAdjustMethod = pAdjustMethod
          )
        
        # self$results$debug$setContent(model)
        
        # Description Results Table ----
        calculateDESCtable <- function() {
          if (self$results$DESCtable$isNotFilled() |
              self$results$DESCtable$rowCount == 0) {
            table <- self$results$DESCtable
            mess1 <-
              switch(model$type,
                     both = " both types of ",
                     nudif = " nonuniform ",
                     udif = " uniform ")
            if (model$purification &
                is.null(model$anchor.names) & model$match ==
                "score") {
              pur <- "with "
            } else {
              pur <- "without "
            }
            
            if (class(model) == "Logistic") {
              df <- ifelse(type == "both", 2, 1)
            } else {
              df <-
                ifelse(type == "both", 2 * length(focalName), length(focalName))
            }
            
            table$addRow(rowKey = 1, values = list(
              bob =
                paste0(
                  "Detection of",
                  mess1,
                  "Differential Item Functioning using the "
                  ,
                  switch(
                    class(model),
                    Logistic = "Logistic regression method ",
                    genLogistic = "Generalized logistic regression method "
                  ),
                  pur,
                  "item purification and with ",
                  length(model$focalName),
                  " reference group(s) and ",
                  df,
                  " degree(s) of freedom."
                )
            ))
            
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob = paste0(
                "DIF flagging criterion: ",
                ifelse(
                  model$criterion == "Wald",
                  paste0(
                    "Wald test of joint significance on ",
                    df,
                    " degree(s) of freedom"
                  ),
                  "Likelihood ratio test"
                )
              ))
            )
            
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            if (model$pAdjustMethod == "none")
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(bob = "No p-value adjustment for multiple comparisons")
              )
            else {
              pAdjMeth <- switch(
                model$pAdjustMethod,
                bonferroni = "Bonferroni",
                holm = "Holm",
                hochberg = "Hochberg",
                hommel = "Hommel",
                BH = "Benjamini-Hochberg",
                BY = "Benjamini-Yekutieli"
              )
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(
                  bob = paste(
                    "Multiple comparisons made with ",
                    pAdjMeth,
                    " adjustment of p-values."
                  )
                )
              )
            }
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            
            if (model$purification &
                is.null(model$anchor.names) &
                model$match == "score") {
              if (model$nrPur <= 1) {
                word <- " iteration"
              } else {
                word <- " iterations"
              }
              if (!model$convergence) {
                table$addRow(
                  rowKey = self$results$DESCtable$rowCount + 1,
                  values = list(
                    bob = paste(
                      "WARNING: no item purification convergence after ",
                      model$nrPur,
                      word,
                      sep = " "
                    )
                  )
                )
                loop <- NULL
                for (i in 1:model$nrPur) {
                  loop[i] <- sum(model$difPur[1, ] == model$difPur[i + 1, ])
                }
                if (max(loop) != length(model$genLogistik)) {
                  table$addRow(
                    rowKey = self$results$DESCtable$rowCount + 1,
                    values = list(
                      bob = paste(
                        "(Note: no loop detected in less than ",
                        model$nrPur,
                        word,
                        ")",
                        sep = ""
                      )
                    )
                  )
                } else {
                  table$addRow(
                    rowKey = self$results$DESCtable$rowCount + 1,
                    values = list(
                      bob = paste(
                        "(Note: loop of length ",
                        min((1:model$nrPur)[loop ==
                                              length(model$genLogistik)]),
                        " in the item purification process)",
                        sep = " "
                      )
                    )
                  )
                  table$addRow(
                    rowKey = self$results$DESCtable$rowCount + 1,
                    values = list(
                      bob = paste(
                        "WARNING: following results based on the last iteration of the purification"
                      )
                    )
                  )
                }
              } else {
                table$addRow(
                  rowKey = self$results$DESCtable$rowCount + 1,
                  values = list(
                    bob = paste("Convergence reached after ", model$nrPur, word, sep = " ")
                    
                  )
                )
                table$addRow(
                  rowKey = self$results$DESCtable$rowCount + 1,
                  values = list(bob = "")
                )
              }
            }
            
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob = paste0(
                "Grouping variable(s): ", list(self$options$group)
              ))
            )
            
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob = paste0(
                "Reference group(s): ", list(model$focalName)
              ))
            )
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            
            if (model$match[1] == "score") {
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(bob = "Matching variable: Test score")
              )
            } else {
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(bob = paste0(
                  "Matching variable: ", self$options$matchVar
                ))
              )
            }
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            if (is.null(model$anchor.names) |
                model$match != "score") {
              itk <- 1:length(model$genLogistik)
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(bob = "No set of anchor items was provided")
              )
            }
            else {
              itk <- (1:length(model$genLogistik))[!is.na(model$genLogistik)]
              table$addRow(
                rowKey = self$results$DESCtable$rowCount + 1,
                values = list(bob =  "Anchor items (provided by the user): ")
              )
              for (i in 1:length(self$options$anchor)){
              table$addRow(
                rowKey = self$results$DESCtable$rowCount +
                  1,
                values = list(bob = self$options$anchor[[i]])
              )
              }
            }
            table$addRow(rowKey = self$results$DESCtable$rowCount + 1,
                         values = list(bob = ""))
            
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob =  "Effect size (Nagelkerke's 'R\u00B2'):")
            )
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob =  "'A': negligible effect")
            )
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob =  "'B': moderate effect")
            )
            table$addRow(
              rowKey = self$results$DESCtable$rowCount + 1,
              values = list(bob =  "'C': large effect")
            )
          }
        }
        
        DESCstate <- self$results$DESCtable$state
        
        if (!is.null(DESCstate)) {
          # ... populate the table from the state
        } else {
          DESCstate <- calculateDESCtable()
          # ... populate the table from the state
          self$results$DESCtable$setState(DESCstate)
        }
        
        # DIF Results Table ----
        
        calculateDIFTable <- function() {
          for (i in 1:length(Data)){
            if (self$results$DIFtable$isNotFilled()) {
              table <- self$results$DIFtable
              for (i in 1:length(Data)) {
                table$setRow(
                  rowNo = i,
                  values = list(
                    item = model$names[i],
                    p = model$adjusted.p[i],
                    difType = ifelse(
                      model$adjusted.p[i] <= alpha,
                      ifelse(model$logitPar[i, 4] == 0, "Uni", "Non-Uni"),
                      "."
                    ),
                    #p = paste0(round(model$p.value[i], 3), symnum(model$p.value[i], c(0, 0.001, 0.01, 0.05, 0.1, 1), symbols = c("***", "**", "*", ".", ""))),
                    effSize = model$deltaR2[i],
                    ZT = ifelse(model$adjusted.p[i] <= alpha, model$ZT[i], "No DIF"),
                    JG = ifelse(model$adjusted.p[i] <= alpha, model$JG[i], "No DIF")
                  )
                )
              }
            }
          
          # Highlight DIF results table
            if (self$options$difFlagScale == "zt") {
              if (model$ZT[i] %in% c("B", "C") & model$adjusted.p[i] <= alpha) {
                highlight(table, "ZT", i)
                highlight(table, "item", i)
              }
            } else {
              if (model$JG[i] %in% c("B", "C") &
                  model$adjusted.p[i] <= alpha) {
                highlight(table, "JG", i)
                highlight(table, "item", i)
              }
            }
          }
          # Set notes
          if (self$options$difFlagScale == "zt") {
            table$setNote(key = "ZT", note = "Zumbo & Thomas (ZT): 'A' = 'R\u00B2' 0 <> 0.13, 'B' = 'R\u00B2' 0.13 <> 0.26, 'C' = 'R\u00B2' 0.26 <> 1")
          } else {
            table$setNote(key = "JG", note = "Jodoin & Gierl (JG): 'A' = 'R\u00B2' 0 <> 0.035, 'B' = 'R\u00B2' 0.035 <> 0.07, 'C' = 'R\u00B2' 0.07 <> 1")
          }
        }
        
        DIFstate <- self$results$DIFtable$state
        
        if (!is.null(DIFstate)) {
          # ... populate the table from the state
        } else {
          DIFstate <- calculateDIFTable()
          # ... populate the table from the state
          self$results$DIFtable$setState(DIFstate)
        }
        
        table <- self$results$gcTable
        if (table$rowCount == 0) {
          table$addRow(
            rowKey = 1,
            values = list(item = "No items were flagged as exhibiting statistically significant DIF", NULL, NULL, NULL)
          )
        }
        
        # ICC plot data ----
        
        if (!is.null(self$options$plotVarsICC)) {
          if (self$results$ICCplots$isNotFilled()) {
            items <- self$options$plotVarsICC
            
            if (match == "score") {
              match <- rowSums(Data)
            }
            
            for (i in unique(items)) {
              private$.checkpoint()
              plotData <-
                data.frame(Data[, colnames(Data) == i], match, group)
              
              colnames(plotData) <-
                c(i, "match", "group")
              
              imageICC <- self$results$ICCplots$get(key = i)
              imageICC$setState(list(plotData, model))
            }
          }
        }
        
        # LRT plot data ----
        
        # if (self$results$LRTplot$isNotFilled()) {
        #   imageLRT <- self$results$LRTplot
        #   imageLRT$setState(model)
        # }
      },
      
      .plotICC = function(imageICC, ...) {
        plotData <- data.frame(imageICC$state[[1]])
        model <- imageICC$state[[2]]
        
        if (!all(self$options$plotVarsICC %in% self$options$item)) {
          stop(
            paste0(
              "Not all items selected to be plotted have been evaluated, please remove: ",
              self$options$plotVarsICC[!self$options$plotVarsICC %in% self$options$item]
            ),
                   call. = FALSE
          )
        }
        
        p <- ggplot(data = plotData,
                    aes(
                      x = as.numeric(plotData$match),
                      y = as.integer(plotData[, 1]),
                      colour = as.character(plotData$group)
                    )) +
          geom_smooth(
            method = "glm",
            se = TRUE,
            method.args = (family = "binomial")
          ) +
          labs(colour = "Group membership") +
          ggtitle(
            paste("Item: ", colnames(plotData)),
            subtitle = paste(
              "Effect Size: ",
              round(model$deltaR2[model$names == colnames(plotData)[1]], 3),
              " | DIF Classification: ZT = ",
              model$ZT[model$names == colnames(plotData)[1]],
              ", JG = ",
              model$JG[model$names == colnames(plotData)[1]]
            )
          ) +
          xlab(ifelse(
            is.null(self$options$matchVar),
            "Total sore",
            "Supplied matching variable range"
          )) +
          ylab("Probability of endorsement") +
          theme_classic()
        
        print(p)
        TRUE
        
      }#,
      
      # .plotLRT = function(imageLRT, ...) {
      #   model <- imageLRT$state
      #
      #   plotLRT <-
      #     function (x,
      #               item = 1,
      #               itemFit = "best",
      #               pch = 8,
      #               number = TRUE,
      #               col = "red",
      #               colIC = rep("black", 2),
      #               ltyIC = c(1,
      #                         2),
      #               group.names = NULL,
      #               ...)
      #     {
      #       res <- x
      #       if (class(res) == "Logistic") {
      #         myClass <- "Logistik"
      #       } else {
      #         myClass <- "genLogistik"
      #       }
      #       plot(
      #         res$Logistik,
      #         xlab = "Item",
      #         ylab = paste(x$criterion,
      #                      " statistic", sep = ""),
      #         ylim = c(0, max(c(
      #           res$Logistik,
      #           res$thr
      #         ) + 1, na.rm = TRUE)),
      #         xlim = c(1, length(model$names)),
      #         col = "white",
      #         main = paste("Logistic regression (",
      #                      x$criterion,
      #                      " statistic)",
      #                      sep = "")
      #       )
      #       text(1:length(res$Logistik),
      #            res$Logistik,
      #            1:length(res$Logistik))
      #       if (!is.character(res$DIFitems))
      #         text(res$DIFitems, res$Logistik[res$DIFitems],
      #              res$DIFitems, col = col)
      #
      #       abline(h = res$thr)
      #     }
      #   LRTplot <- plotLRT(model)
      #   print(LRTplot)
      #
      #   TRUE
      # }
    )
  )
