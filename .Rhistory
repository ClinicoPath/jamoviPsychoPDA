alpha(bfi5items) # This provides raw/Cronbach’s and standardized alpha of the
# object specified in brackets. In this case, the object is a datamatrix (bfi5items), and R therefore calculates raw/Cronbach’s and
# standardized alpha, respectively, from the Pearson covariance and
# the Pearson correlation matrices of the data set. This step, in
# combination with the previous one, will allow one to compare
# ordinal alpha with raw/Cronbach’s alpha. One should obtain the
# following results as part of the R output: raw_alpha = .81; std.alpha
# = .81; average_r = .47.
fa(bfi5items) # This provides the factor loadings (MR1), communalities (h2),
# and uniquenesses (u2) for a 1-factor solution of the bfi5items data
# matrix.
fa(examplename$rho) # This provides the factor loadings (MR1), communalities (h2),
# and uniquenesses (u2) for a 1-factor solution of the polychoric
# correlation matrix that was saved under the name examplename.
guttman(examplename$rho) # This provides alternative estimates of reliability for the data
# communalities”. Since the specified data matrix is, in this case, a
# polychoric correlation matrix, all the reliability estimates represent
# ordinal versions. (We note that the guttman syntax command
# includes alpha (=L3) as one of the reliability estimates—however,
# the alpha syntax command provides additional item
# characteristics, such as the item-total correlations, that may be of
# interest to the user.)
#  [Further details and references with regard to the different
# reliability coefficients featured in the guttman command can be
# found in Revelle, 2011.]
guttman(bfi5items) # Equivalent to the command above, this provides a list of
# alternative estimates of reliability for the data matrix specified in
# brackets. Since bfi5items is a raw data matrix, the reliability
# estimates represent, in this case, Pearson correlation based
# reliability estimates.
omega(examplename$rho) # This provides the ordinal versions of the reliability coefficients
omega (hierarchical, asymptotic, and total), because their
# omega (hierarchical, asymptotic, and total), because their
# calculation is based on the polychoric correlation matrix
# ‘examplename’.
omega(bfi5items) # This provides omega coefficients for the data matrix bfi5items.
# communalities”. Since the specified data matrix is, in this case, a
# polychoric correlation matrix, all the reliability estimates represent
# ordinal versions. (We note that the guttman syntax command
# includes alpha (=L3) as one of the reliability estimates—however,
# the alpha syntax command provides additional item
# characteristics, such as the item-total correlations, that may be of
# interest to the user.)
#  [Further details and references with regard to the different
# reliability coefficients featured in the guttman command can be
# found in Revelle, 2011.]
guttman(bfi5items) # Equivalent to the command above, this provides a list of
# omega (hierarchical, asymptotic, and total), because their
# calculation is based on the polychoric correlation matrix
# ‘examplename’.
omega(bfi5items) # This provides omega coefficients for the data matrix bfi5items.
getwd()
jmvtools::addAnalysis("ordinalReliability", "Ordinal Reliability")
getwd()
jmvtools::check()
jmvtools::addAnalysis(name = "ordinalReliability", title = "Ordinal Reliability")
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
paste0(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = digits, ...), nsmall = digits, ...),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = digits, ...), nsmall = digits, ...),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = digits)
)
}
deLong.test <-
function(data,
classVar,
pos_class = 1,
ref = NULL,
conf.level = 0.95) {
# if (length(classVar) != dim(data)[1]) {
#    stop("\n The number of rows in data must match the length of classVar\n")}
id.pos <- classVar == pos_class
if (sum(id.pos) < 1) {
stop("\n wrong level specified!\n")
}
if (dim(data)[2] < 2) {
stop("\n data must contain at least two columns!\n")
}
if (dim(data)[1] < 2) {
stop("\n data must contain at least two rows!\n")
}
nn <- sum(!id.pos)
np <- sum(id.pos)
nauc <- ncol(data)
if (is.null(ref)) {
L <- matrix(0, nrow = nauc * (nauc - 1) / 2, ncol = nauc)
newa <- 0
for (i in 1:(nauc - 1)) {
newl <- nauc - i
L[(newa + 1):(newa + newl), i] <- rep(1, newl)
L[(newa + 1):(newa + newl), ((i + 1):(i + newl))] <-
diag(-1, nrow = newl, ncol = newl)
newa <- newa + newl
}
}
else {
# test for superiority of one method against all others)
if (ref > nauc)
stop(
paste(
"Reference ref must be one of the markers (1...",
nauc,
" in this case)",
sep = ""
)
)
L <- matrix(1, ncol = nauc, nrow = nauc - 1)
L[, -ref] <- diag(-1, nrow = nauc - 1, ncol = nauc - 1)
}
markern <- as.matrix(data[!id.pos,])
markerp <- as.matrix(data[id.pos,])
###
### compute wilcox statistic
###
WK.STAT <- function(data, y) {
r <- rank(c(data, y))
n.data <- length(data)
n.y <- length(y)
STATISTIC <-
sum(r[seq_along(data)]) - n.data * (n.data + 1) / 2
STATISTIC
}
auc <- vector("numeric", length = nauc)
for (r in 1:nauc) {
auc[r] <- WK.STAT(markerp[, r], markern[, r])
}
auc <- auc / (nn * np)
###
### if AUCs smaller than 0.5: 1-auc
###
if (any(auc < 0.5)) {
data[, auc < 0.5] <- -data[, auc < 0.5]
auc[auc < 0.5] <- 1 - auc[auc < 0.5]
markern <- as.matrix(data[!id.pos,])
markerp <- as.matrix(data[id.pos,])
}
V10 <- matrix(0, nrow = np, ncol = nauc)
V01 <- matrix(0, nrow = nn, ncol = nauc)
tmn <- t(markern)
tmp <- t(markerp)
for (i in 1:np) {
V10[i,] <- rowSums(tmn < tmp[, i]) + 0.5 * rowSums(tmn == tmp[, i])
}
for (i in 1:nn) {
V01[i,] <- rowSums(tmp > tmn[, i]) + 0.5 * rowSums(tmp == tmn[, i])
}
V10 <- V10 / nn
V01 <- V01 / np
W10 <- cov(V10)
W01 <- cov(V01)
###
### estimated covariance matrix
###
S <- W10 / np + W01 / nn
###
### compute variances of AUCs and test for AUC > 0.5
###
### Hanley, McNeil (1982)
q1 <- auc / (2 - auc)
q2 <- 2 * auc ^ 2 / (1 + auc)
### Haney, McNeil (1982) / Bamber (1975)
aucvar <-
(auc * (1 - auc) + (np - 1) * (q1 - auc ^ 2) + (nn - 1) * (q2 - auc ^ 2)) / (np *
nn)
zhalf <- (auc - 0.5) / sqrt(aucvar)
phalf <- 1 - pnorm(zhalf)
zdelong <- (auc - 0.5) / sqrt(diag(S))
pdelong <- 1 - pnorm(zdelong)
### global p-value
###
aucdiff <- L %*% auc
# Original function used rms::matinv() for all solves/inversions.
# That function was jenky and didn't work
z <- t(aucdiff) %*% MASS::ginv(L %*% S %*% t(L)) %*% aucdiff
p <-
pchisq(z, df = qr(L %*% S %*% t(L))$rank, lower.tail = FALSE)
if (is.null(ref)) {
cor.auc <- matrix(ncol = 1, nrow = nauc * (nauc - 1) / 2)
ci <- matrix(ncol = 2, nrow = nauc * (nauc - 1) / 2)
ctr <- 1
rows <-
vector("character", length = (nauc * (nauc - 1) / 2))
pairp <- matrix(nrow = nauc * (nauc - 1) / 2, ncol = 1)
quantil <- qnorm(1 - (1 - conf.level) / 2)
for (i in 1:(nauc - 1)) {
for (j in (i + 1):nauc) {
cor.auc[ctr] <- S[i, j] / sqrt(S[i, i] * S[j, j])
LSL <-
t(c(1, -1)) %*% S[c(j, i), c(j, i)] %*% c(1, -1)
# Original function used rms::matinv() for all solves/inversions.
# That function was jenky and didn't work
tmpz <-
(aucdiff[ctr]) %*% MASS::ginv(LSL) %*% aucdiff[ctr]
pairp[ctr] <- 1 - pchisq(tmpz, df = qr(LSL)$rank)
ci[ctr,] <-
c(aucdiff[ctr] - quantil * sqrt(LSL),
aucdiff[ctr] + quantil * sqrt(LSL))
rows[ctr] <- paste(i, j, sep = " vs. ")
ctr <- ctr + 1
}
}
} else {
cor.auc <- matrix(ncol = 1, nrow = nauc - 1)
ci <- matrix(ncol = 2, nrow = nauc - 1)
rows <- vector("character", length = nauc - 1)
pairp <- matrix(nrow = nauc - 1, ncol = 1)
comp <- (1:nauc)[-ref]
for (i in 1:(nauc - 1)) {
cor.auc[i] <-
S[ref, comp[i]] / sqrt(S[ref, ref] * S[comp[i], comp[i]])
LSL <-
t(c(1, -1)) %*% S[c(ref, comp[i]), c(ref, comp[i])] %*% c(1, -1)
# Original function used rms::matinv() for all solves/inversions.
# That function was jenky and didn't work
tmpz <- aucdiff[i] %*% MASS::ginv(LSL) %*% aucdiff[i]
pairp[i] <- 1 - pchisq(tmpz, df = qr(LSL)$rank)
ci[i,] <-
c(aucdiff[i] - quantil * sqrt(LSL),
aucdiff[i] + quantil * sqrt(LSL))
rows[i] <- paste(ref, comp[i], sep = " vs. ")
}
}
newres <- as.data.frame(cbind(aucdiff, ci, pairp, cor.auc))
names(newres) <-
c("AUC Difference",
"CI(lower)",
"CI(upper)",
"P.Value",
"Correlation")
rownames(newres) <- rows
row.names(ci) <-
row.names(cor.auc) <-
row.names(aucdiff) <- row.names(pairp) <- rows
colnames(ci) <-
c(paste0(100 * conf.level, "% CI (lower)"),
paste0(100 * conf.level, "% CI (upper)"))
names(auc) <- 1:nauc
auc <-
as.data.frame(cbind(auc, sqrt(aucvar), phalf, sqrt(diag(S)), pdelong))
colnames(auc) <-
c("AUC",
"SD(Hanley)",
"P(H0: AUC=0.5)",
"SD(DeLong)",
"P(H0: AUC=0.5)")
ERG <-
list(
AUC = auc,
difference = newres,
covariance = S,
global.z = z,
global.p = p
)
class(ERG) <- "DeLong"
ERG
}
deLong.test(data = suicide[,c(1,3)], classVar = suicide$suicide)
deLong.test(data = suicide[,c(1,3)], classVar = as.numeric(suicide$suicide))
x <- deLong.test(data = suicide[,c(1,3)], classVar = as.numeric(suicide$suicide))
x
print.DeLong(x)
format(round(x$AUC, digits = digits, ...), nsmall = digits, ...)
format(round(x$AUC, digits = digits), nsmall = digits)
format(round(x$AUC, digits = 3), nsmall = 3)
format(round(x$difference, digits = 3), nsmall = 3)
print.DeLong <-
function(x) {
paste0(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = 3), nsmall = 3),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong(x)
print.DeLong <-
function(x) {
c(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = 3), nsmall = 3),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong <-
function(x) {
return(c(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = 3), nsmall = 3),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
))
}
print.DeLong(x)
?paste
paste0(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3))
print.DeLong <-
function(x) {
cat(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3)),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = 3), nsmall = 3),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong <-
function(x) {
cat(
"<p> Estimated AUC's: </p>",
format(round(x$AUC, digits = 3), nsmall = 3),
"<p> Pairwise comparisons: </p>",
format(round(x$difference, digits = 3), nsmall = 3),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong(x)
print.DeLong <-
function(x) {
cat(
"<p> Estimated AUC's: </p>",
unlist(format(round(x$AUC, digits = 3), nsmall = 3)),
"<p> Pairwise comparisons: </p>",
unlist(format(round(x$difference, digits = 3), nsmall = 3)),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong(x)
x$AUC
unlist(x$AUC))
unlist(x$AUC)
paste0(
"<p> Estimated AUC's: </p>",
paste0(format(round(x$AUC, digits = 3), nsmall = 3)),
"<p> Pairwise comparisons: </p>",
paste0(format(round(x$difference, digits = 3), nsmall = 3)),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
print.DeLong <-
function(x) {
paste0(
"<p> Estimated AUC's: </p>",
paste0(format(round(x$AUC, digits = 3), nsmall = 3)),
"<p> Pairwise comparisons: </p>",
paste0(format(round(x$difference, digits = 3), nsmall = 3)),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
unlist(x$AUC)
print.DeLong(x)
paste0(format(round(x$AUC, digits = 3), nsmall = 3))
format(round(x$AUC, digits = 3), nsmall = 3)
y <- format(round(x$AUC, digits = 3), nsmall = 3)
y
print.DeLong <-
function(x) {
y = format(round(x$AUC, digits = 3), nsmall = 3)
paste0(
"<p> Estimated AUC's: </p>",
y,
"<p> Pairwise comparisons: </p>",
paste0(format(round(x$difference, digits = 3), nsmall = 3)),
"<p> Overall test: </p>",
"<p> p-value = </p>",
format.pval(x$global.p, digits = 3)
)
}
print.DeLong(x)
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
paste0(
cat("Estimated AUC's:\n")
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...))
cat("\n Pairwise comparisons:\n")
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...))
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits),
"\n"
)))
}
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
paste0(
cat("Estimated AUC's:\n"),
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...)),
cat("\n Pairwise comparisons:\n"),
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...)),
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits),
"\n"
)))
}
print.DeLong(x)
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat("Estimated AUC's:\n"),
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...)),
cat("\n Pairwise comparisons:\n"),
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...)),
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits),
"\n"
))
}
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(
cat("Estimated AUC's:\n"),
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...)),
cat("\n Pairwise comparisons:\n"),
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...)),
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits),
"\n"
)))
}
print.DeLong(x)
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(
cat("Estimated AUC's:\n")
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...))
cat("\n Pairwise comparisons:\n"),
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...))
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits)
"\n"
)))
}
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(
cat("Estimated AUC's:\n")
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...))
cat("\n Pairwise comparisons:\n")
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...))
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits)
"\n"
)))
}
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat(
cat("Estimated AUC's:\n")
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...))
cat("\n Pairwise comparisons:\n")
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...))
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits)
"\n"
)))
}
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits)
"\n"
))
print.DeLong <-
function(x, digits = max(3, getOption("digits") - 3), ...) {
cat("Estimated AUC's:\n")
print(format(round(x$AUC, digits = digits, ...), nsmall = digits, ...))
cat("\n Pairwise comparisons:\n")
print(format(round(x$difference, digits = digits, ...), nsmall = digits, ...))
cat(paste(
"\n Overall test:\n p-value =",
format.pval(x$global.p, digits = digits),
"\n"
))
}
print.DeLong(x)
paste0("</P", print.DeLong(x), "</p>")
paste0("</p>", print.DeLong(x), "</p>")
paste0("</p>", capture.output(print.DeLong(x)), "</p>")
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
include_examples
