R2cox1 <-  1- exp((m1$deviance - m1$null.deviance)/n)
R2nag1 <-  R2cox1/(1-exp((-m1$null.deviance)/n))
R2nag1
deltaNagR2 <- R2nag0 - R2nag1
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 200)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
# Adjust and normalize
myBoot$t <- myBoot$t+hypTrueEff/se
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
alpha <- 0.05
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
plot(D)
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi <- 1 - approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = p.lo)[[1]]
p.hi
p.lo
# Does this math still hold in the emp. dist.?
power <- p.hi + p.lo
# Type-S error rate
typeS <- p.lo / power
typeS
power
# Density values for use below shifted by the value of our hypothesised True Effect
# Adjust and normalize
myBoot$t <- (myBoot$t+hypTrueEff)/se
plot(myBoot$t)
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 200)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
# Adjust and normalize
myBoot$t <- (myBoot$t+hypTrueEff)/se
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
plot(D)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi <- 1 - approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = p.lo)[[1]]
# Does this math still hold in the emp. dist.?
power <- p.hi + p.lo
# Type-S error rate
typeS <- p.lo / power
# typeM
estimate <- hypTrueEff + se * sample(myBoot$t, replace = T, size = 5000)
significant <- estimate < se * qUpper  | estimate > se * qUpper
typeM <- mean(abs(estimate)[significant]) / hypTrueEff
empRes <- list(typeM = typeM, typeS = typeS)
return(empRes)
empRes
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 200)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
# Adjust and normalize
myBoot$t <- (myBoot$t-hypTrueEff)/se
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
plot(D)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi
p.lo
p.hi <- 1 - approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = p.lo)[[1]]
p.hi
p.lo
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi <- approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = p.lo)[[1]]
p.lo
p.hi
# Does this math still hold in the emp. dist.?
power <- p.hi + p.lo
# Type-S error rate
typeS <- p.lo / power
p.hi/se
?ecdf
ecdf(myBoot$t)
x <- ecdf(myBoot$t)
x(p.hi)
x(p.lo)
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
x(p.lo)
plot(x)
p.hi
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
qUpper
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 200)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
# Adjust and normalize
myBoot$t <- (myBoot$t-hypTrueEff)
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
x <- ecdf(myBoot$t)
plot(x)
qUpper
qLower
x(qUpper)
x(qLower)
summary(x)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(myBoot$t, c(alpha/2, 1-(alpha/2)))
quant
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
quant
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(myBoot$t, c(alpha/2, 1-(alpha/2)))
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
x <- ecdf(myBoot$t)
x(qLower)
x(qUpper)
x
plot(x)
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi <- approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = p.lo)[[1]]
p.hi
p.lo
plot(D)
cbind(myBoot$t, D$x
)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha/2, 1-(alpha/2)))
# points in the probability distribution matching the Lower and Upper quantiles
qLower <- quant[[1]]
qUpper <- quant[[2]]
p.lo <- approx(D$x, D$y, xout = -p.lo)[[1]]
p.lo
p.hi
# Does this math still hold in the emp. dist.?
power <- p.hi + p.lo
# Type-S error rate
typeS <- p.lo / power
# typeM
estimate <- hypTrueEff + se * sample(myBoot$t, replace = T, size = 5000)
significant <- estimate < se * qUpper  | estimate > se * qUpper
typeM <- mean(abs(estimate)[significant]) / hypTrueEff
empRes <- list(typeM = typeM, typeS = typeS, power = power)
return(empRes)
empRes
# Here there be monsters
p.hi <- qUpper - hypTrueEff
p.lo <- qLower - hypTrueEff
p.hi <- 1 - approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = -p.lo)[[1]]
# Does this math still hold in the emp. dist.?
power <- p.hi + p.lo
# Type-S error rate
typeS <- p.lo / power
# typeM
estimate <- hypTrueEff + se * sample(myBoot$t, replace = T, size = 5000)
significant <- estimate < se * qUpper  | estimate > se * qUpper
typeM <- mean(abs(estimate)[significant]) / hypTrueEff
empRes <- list(typeM = typeM, typeS = typeS, power = power)
empRes
# typeM
estimate <- hypTrueEff + se * sample(D$x, replace = T, size = 5000)
significant <- estimate < se * qUpper  | estimate > se * qUpper
typeM <- mean(abs(estimate)[significant]) / hypTrueEff
empRes <- list(typeM = typeM, typeS = typeS, power = power)
empRes
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 500)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
myBoot$t <- (myBoot$t-hypTrueEff)
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
plot(D)
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 1000)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
myBoot$t <- (myBoot$t-hypTrueEff)
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
plot(D)
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
hypTrueEff <- c(0.13, 0.26, 0.035, 0.07)
c(0.13, 0.26, 0.035, 0.07)
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
list(x)
list("X")
list(c("X", "Y")
)
x <- list(c("X", "Y"))
length(x)
length(x[1])
length(x[[1]])
empRes
empRes
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
rownames(D)
rownames(verbal)
rownames(verbal)[10]
rownames(verbal)[10]
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
hypTrueEff
rep(hypTrueEff, times = 2)
jmvtools::install()
jmvtools::install()
hypTrueEff
hypTrueEff[0.130]
hypTrueEff
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
# Get bootstrapped distribution
myBoot <- boot(DATA, NagR2, R = 1000)
# se of emp. dist.
se <- print.bootSE(myBoot)[[3]]
# Density values for use below shifted by the value of our hypothesised True Effect
# myBoot$t <- (myBoot$t - hypTrueEff)
# I'm dividing by SE to put it on the right scale?
D <- density(myBoot$t, n = 1024)
# `pemp` probability of observed deltaNagR2 under the above emp. dist.
#pObsD <- approx(D$x, D$y, xout = myBoot$t0)[[1]]
# length 2 vector of quantiles matching bottom alpha/2 and upper alpha/2 in the emp. dist.
quant <- quantile(D$x, c(alpha / 2, 1 - (alpha / 2)))
# Does this math still hold in the emp. dist.?
# powerR <- p.hi + p.lo
mb <- replicate(self$options$sims, mean(sample(myBoot$t, replace = T)))
# Does this math still hold in the emp. dist.?
# powerR <- p.hi + p.lo
mb <- replicate(5000, mean(sample(myBoot$t, replace = T)))
# calculate 2.5% and 97.5% quantiles. This will be needed to find the "reject region."
## for the given alpha, returns CI limits (lo and hi)
p.lo <- quantile(mb, alpha/2)
p.hi <- quantile(mb, 1-alpha/2)
p.hi <- quantile(mb, 1-alpha/2)
jmvtools::install()
##1) bootstrapping/sampling the vector x (with replacement)
##2) calculating the mean for each sampling
##3) R=5000 times replicating steps 1) and 2)
##4) the end result of 1-3, is "mb" array of length R.
## All 4 above steps are accomplished by the following one command:
mb <- replicate(5000, mean(sample(myBoot.t, replace = T)))
##1) bootstrapping/sampling the vector x (with replacement)
##2) calculating the mean for each sampling
##3) R=5000 times replicating steps 1) and 2)
##4) the end result of 1-3, is "mb" array of length R.
## All 4 above steps are accomplished by the following one command:
mb <- replicate(5000, mean(sample(myBoot$t, replace = T)))
# calculate 2.5% and 97.5% quantiles. This will be needed to find the "reject region."
## for the given alpha, returns CI limits (lo and hi)
lo <- quantile(mb, alpha/2)
hi <- quantile(mb, 1-alpha/2)
# Here there be monsters
## for the given alpha, returns CI limits (lo and hi)
p.hi <- qUpper# - hypTrueEff
p.lo <- qLower# - hypTrueEff
p.hi <- 1 - approx(D$x, D$y, xout = p.hi)[[1]]
p.lo <- approx(D$x, D$y, xout = -p.lo)[[1]]
# Does this math still hold in the emp. dist.?
# powerR <- p.hi + p.lo
mb <- replicate(5000, mean(sample(myBoot$t, replace = T)))
## shifts array x by the effect size delta
x.shift <- myBoot$t + hypTrueEff
## steps 1-4 as above but applied for the shifted sample x.shift
mb.shift <- replicate(5000, mean(sample(x.shift, replace = T)))
##returns the fraction of elements of mb.shift that fall into the reject region of mb.
rejects= sum((mb.shift<p.lo | mb.shift>p.hi)==T)
##calculates the proportion of rejects among all bootstrapped samples.
##This is the power of the test.
powerR <- rejects/5000
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
jmvtools::install()
